<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Iterator pattern in STL</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/reveal.css" />
    <link rel="stylesheet" href="night.css">
    <link rel="stylesheet" href="tuning.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/plugin/highlight/monokai.min.css"
        integrity="sha512-z8wQkuDRFwCBfoj7KOiu1MECaRVoXx6rZQWL21x0BsVVH7JkqCp1Otf39qve6CrCycOOL5o9vgfII5Smds23rg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
        integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Titillium+Web:200,300&amp;subset=latin-ext" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code" rel="stylesheet">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <section>
                    <h2>The Iterator Pattern</h2>
                    <img src="img/presentation-logo.drawio.png" alt="">
                    <h3>in Standard Template Library</h3>
                </section>
                <section>
                    <h2>Scope & goals</h2>
                    <ul>
                        <li>Why was STL designed the way it was?</li>
                        <li class="fragment">C++ iterators walkthrough</li>
                        <li class="fragment">The next big step in the STL evolution</li>
                        <li class="fragment">Custom iterators</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>STL's design principles</h2>
                    <ul>
                        <li>Alexander Stepanov <a href="https://www.youtube.com/watch?v=COuHLky7E2Q">youtube.com/watch?v=COuHLky7E2Q</a></li>
                        <li>Bjarne Stroustroup <a href="https://www.stroustrup.com/rules.pdf">stroustrup.com/rules.pdf</a></li>
                        <li>Jonathan Boccara <a href="https://www.fluentcpp.com/2017/04/18/the-design-of-the-stl/">fluentcpp.com/2017/04/18/the-design-of-the-stl/</a></li>
                    </ul>
                </section>
                <section>
                    <h2 class="accent">The principles</h2>
                    <ol class="loose">
                        <li class="fragment">Separation of algorithms from the data structures</li>
                        <li class="fragment">Generality and Specialization</li>
                    </ol>
                </section>
            </section>
            <section>
                <section>
                    <h3>What's an iterator?</h3>
                    <ul class="loose">
                        <li>A container-traversal tool</li>
                        <li class="fragment">An object (with a specific API)</li>
                        <li class="fragment">Sort of a pointer to container's elements</li>
                    </ul>
                </section>
                <section>
                    <h3>What's so special about iterators?</h3>
                    <ul>
                        <li><span class="accent">Separation</span> of algorithms from the data structures</li>
                        <li class="fragment"><span class="accent">Universal traversal</span> method over a range of elements</li>
                        <li class="fragment">A single std::find() for all data structures instead of separate overloads for vector, map, set, deque,...</li>
                        <li class="fragment"><span class="accent">Loose coupling</span> between algorithms and containers</li>
                        <li class="fragment">Open-Closed Principle - extension of container's capabilities by new <span class="accent">generic</span> algorithms, not by modification of the containers themselves</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Pointer semantics</h2>
                    <h3>of a C++ iterator</h3>
                </section>
                <section>
                    <h2>Iterator dereference</h2>
                    <img src="img/iterator-dereference.png">
                </section>
                <section>
                    <h2>Custom iterator dereference</h2>
                    <img src="img/iterator-dereference-struct.png" class="w80">
                </section>
                <section>
                    <h2>Iterator's <span class="fira">operator->()</span></h2>
                    <img src="img/iterator-arrow.png" alt="">
                </section>
                <section>
                    <h3>Custom iterator's <span class="fira">operator->()</span></h3>
                    <img src="img/iterator-arrow-struct.png" class="w80">
                </section>
                <section>
                    <h3>Iterator incrementation/decrementation</h3>
                    <img src="img/iterator-increment-decrement.png" class="w80">
                </section>
                <section>
                    <h3>Custom iterator implementation</h3>
                    <h4>of increment/decrement</h4>
                    <h4>insert missing pic here</h4>
                </section>
                <section>
                    <h3>Pointer semantics</h3>
                    <h5>makes STL algorithms applicable to containers but also to old-school arrays</h5>
                    <img src="img/pointer-semantics.png" alt="">
                </section>
            </section>
            <section>
                <section><h2>Iterator categories</h2></section>
                <section>
                    <h2>Named requirements</h2>
                    <q class="accent">Written expectations about C++ types and objects</q>
                    <p class="fragment">Used in the C++ standard to state those expectations</p>
                    <p class="fragment">One requirement can be used to define another (like in maths)</p>
                    <p class="fragment">Usually paired with some helpers that express those expectations in the code</p>
                    <a href="https://en.cppreference.com/w/cpp/named_req" class="fragment">en.cppreference.com/w/cpp/named_req</a>
                </section>
                <section>
                    <h3><q>DefaultConstructible</q></h3>
                    <img src="img/default_constructible.png" class="w80">
                </section>
                <section>
                    <h3><q>Predicate</q></h3>
                    <img src="img/predicate.png" class="w90">
                </section>
                <section>
                    <h2>Iterator categories</h2>
                    <img src="img/iterator-categories.png" alt="">
                </section>
                <section>
                    <h2>LegacyIterator</h2>
                    <p>The base set of requirements for all iterators</p>
                    <ul class="fragment">
                        <li><i>CopyConstructible</i></li>
                        <li><i>CopyAssignable</i></li>
                        <li><i>Destructible</i></li>
                        <li><i>Swappable</i></li>
                        <li>Specialization of <span class="fira accent">std::iterator_traits&lt;Iter&gt;</span></li>
                        <li>Both expressions <span class="fira accent">*iter</span> and <span class="fira accent">++iter</span> are valid</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h3>Things to remember when writing your own iterator</h3>
                </section>
                <section>
                    <ul>
                        <li>inherit from std::iterator</li>
                        <li>but std::iterator got deprecated?</li>
                        <li>specialize some functions (advance, next)</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h3>Iterator related special functions</h3>
                    <ul>
                        <li>advance</li>
                        <li>next</li>
                    </ul>
                </section>
                <section>
                    <h3><span class="fira">std::begin()</span> vs <span class="fira">obj.begin()</span></h3>
                </section>
                <section>
                    <h3>5 standard iterator types in C++</h3>
                </section>
                <section>
                    <h3>Iterator invalidation</h3>
                </section>
                <section>
                    <h3>Proxy iterators</h3>
                </section>
                <section>
                    <h3>The curious case of <span class="fira accent">std::vector&lt;bool&gt;</span></h3>
                    <img src="img/vector-of-bool.png" class="w80">
                </section>
                <section>
                    <h3><span class="fira accent">std::basic_string</span> to the rescue</h3>
                    <img src="img/string-of-bool.png" alt="">
                </section>
            </section>
            <section>
                <section>
                    <h2>Iterator adaptors</h2>
                    https://en.cppreference.com/w/cpp/iterator/counted_iterator

                </section>
            </section>
            <section>
                <section>
                    <h2>MaxPool</h2>
                    <img src="img/max_pool_animation.gif" alt="">
                </section>
                <section>
                    <h3>MaxPool algorithm</h3>
                    <ul class="loose">
                        <li>For each output tensor element...</li>
                        <li>Calculate the kernel position (top-left corner)</li>
                        <li>Iterate over the kernel elements row-by-row</li>
                        <li>Select the element with the maximum value</li>
                        <li>Requires transformation of an element's 2D coordinate to an address in the flat tensor</li>
                    </ul>
                </section>
                <section>
                    <h3>Kernel position calculation</h3>
                    <img src="img/kernel-pos-calculation.png" alt="">
                </section>
                <section>
                    <h3>Kernel position calculation</h3>
                    <h4>(with padding)</h4>
                    <img src="img/kernel-pos-calculation-padding.png" alt="">
                </section>
                <section>
                    <h3>Kernel position calculation</h3>
                    <h4>(with padding, strides and dilations)</h4>
                    <img src="img/kernel-pos-calculation-strides-dilations.png" alt="">
                </section>
                <section>
                    <h2>MaxPool</h2>
                    <img src="img/max_pool_animation.gif" alt="">
                    <h3 class="fragment">(ugly) code time</h3>
                </section>
                <section>
                    <img src="img/no-raw-loops.png" alt="">
                    <h2 class="fragment"><span class="fira accent">std::max_element</span></h2>
                </section>
                <section>
                    <h2>kernel::end()</h2>
                    <img src="img/kernel-iterator-end.png" alt="">
                </section>
                <section>
                    <h3>MaxPool</h3>
                    <img src="img/mp-transform.png" alt="">
                    <h3 class="fragment accent"><span class="fira">std::transform</span></h3>
                </section>
            </section>
            <section>
                <section>
                    <h3>#include <span class="accent">&lt;iterator&gt;</span></h3>
                    http://www.cplusplus.com/reference/iterator/
                </section>
                <section>
                    <h3>Output iterators</h3>
                    All forward, bidirectional and random-access iterators that are not constant iterators are also valid output iterators.
                    http://www.cplusplus.com/reference/iterator/OutputIterator/
                </section>
                <section>
                    <h3>Iterator categories</h3>
                    http://www.cplusplus.com/reference/iterator/iterator_traits/
                    <br>
                     For every iterator type, a corresponding specialization of iterator_traits class template shall be defined, with at least the following member types defined:
                </section>
            </section>
            <section>
                <section>
                    <h3>Iterability using an adapter</h3>
                    <pre><code>for (auto elem : enumerate(vector)) {
                        const auto index = elem.first;
                        const auto& value = elem.second;
                    }
                    </code></pre>
                    to be used with types whose API cannot be extended
                </section>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/reveal.min.js"
        integrity="sha512-K7P1+dtPriNNHlE4aJr+JKx1X6R0wvy24QBqL2CxaHc4XdkQjrH2t2FCrgoxZGMh6s1TgigNLEdrWa6NJra6Zg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/plugin/highlight/highlight.min.js"
        integrity="sha512-NVdqCvsrfhXUYzGTEGGBFf5jxheVVcglfdvO8r+WdG0BKMrRYvaiCGIC0S+wf4hkE3Xq43gTd1k3Mwl/UNgdvw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script>
        Reveal.initialize({
            controls: false,
            slideNumber: 'c/t',
            transition: 'slide',
            plugins: [RevealHighlight]
        });
    </script>
</body>

</html>
